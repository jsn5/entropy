<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information Theory for ML: From Bits to Loss Functions</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    <style>
        :root {
            --bg: #faf9f7;
            --bg-card: #fff;
            --text: #37352f;
            --text-muted: #6b7280;
            --accent: #c45d4a;
            --accent-light: rgba(196, 93, 74, 0.1);
            --border: #e5e4e2;
            --success: #2ea043;
            --blue: #4a90e2;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-sans);
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            font-size: 16px;
        }
        .container {
            max-width: 740px;
            margin: 0 auto;
            padding: 60px 24px 100px;
        }
        header {
            margin-bottom: 48px;
            padding-bottom: 32px;
            border-bottom: 1px solid var(--border);
        }
        h1 {
            font-size: 32px;
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 12px;
        }
        .subtitle {
            font-size: 18px;
            color: var(--text-muted);
            font-weight: 400;
        }
        h2 {
            font-size: 22px;
            font-weight: 600;
            margin: 48px 0 16px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
        }
        h2:first-of-type { border-top: none; padding-top: 0; margin-top: 0; }
        h3 {
            font-size: 17px;
            font-weight: 600;
            margin: 32px 0 12px;
        }
        p { margin-bottom: 16px; }
        article { margin-bottom: 48px; }

        /* Section labels */
        .section-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--accent);
            margin-bottom: 8px;
        }

        /* Equation blocks */
        .equation-block {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px 24px;
            margin: 20px 0;
            text-align: center;
        }
        .equation-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
            display: block;
        }
        .equation-explanation {
            font-size: 14px;
            color: var(--text-muted);
            margin-top: 12px;
            text-align: left;
        }

        /* Code blocks */
        .code-breakdown {
            background: #fafafa;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }
        .code-breakdown-header {
            background: #f5f4f2;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .code-breakdown-header .title {
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: 500;
            color: var(--text);
        }
        .code-breakdown-header .lang {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            background: var(--bg);
            padding: 3px 8px;
            border-radius: 4px;
        }
        .code-breakdown pre {
            margin: 0;
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 13px;
            line-height: 2;
            overflow-x: auto;
        }
        .code-breakdown .comment { color: #6b7280; font-style: italic; }
        .code-breakdown .keyword { color: #9333ea; }
        .code-breakdown .function { color: var(--accent); }
        .code-breakdown .variable { color: #1e40af; }
        .code-breakdown .number { color: #0891b2; }
        .code-breakdown .string { color: #16a34a; }
        .code-breakdown .highlight-line {
            display: inline-block;
            width: calc(100% + 40px);
            margin-left: -20px;
            padding-left: 17px;
            background: linear-gradient(90deg, var(--accent-light) 0%, transparent 100%);
            border-left: 3px solid var(--accent);
        }

        /* Visualizations */
        .visualization {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
        }
        .viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .viz-title {
            font-weight: 600;
            font-size: 15px;
        }
        .viz-canvas-container {
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        .viz-canvas-container canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        .viz-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }
        .viz-stats {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg);
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .stat-label { color: var(--text-muted); }
        .stat-value {
            font-family: var(--font-mono);
            font-weight: 500;
            color: var(--text);
        }

        /* Controls */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .slider-label {
            font-size: 14px;
            color: var(--text-muted);
            min-width: fit-content;
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            outline: none;
            flex: 1;
            min-width: 120px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(196,93,74,0.3);
        }
        .parameter-display {
            font-family: var(--font-mono);
            font-size: 13px;
            color: var(--accent);
            background: var(--accent-light);
            padding: 4px 10px;
            border-radius: 4px;
            min-width: 80px;
            text-align: center;
        }
        button {
            font-family: var(--font-sans);
            font-size: 14px;
            font-weight: 500;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        button:hover { background: var(--bg); }
        button.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        button.secondary {
            background: transparent;
        }
        select {
            font-family: var(--font-sans);
            font-size: 14px;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-card);
            cursor: pointer;
        }

        /* Callouts */
        .callout {
            padding: 16px 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 15px;
        }
        .callout.blue {
            background: rgba(74, 144, 226, 0.08);
            border-left: 3px solid var(--blue);
        }
        .callout.accent {
            background: var(--accent-light);
            border-left: 3px solid var(--accent);
        }
        .callout-title {
            font-weight: 600;
            margin-bottom: 6px;
        }

        /* Footer */
        footer {
            margin-top: 48px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Toggle buttons */
        .toggle-group {
            display: flex;
            background: var(--bg);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid var(--border);
        }
        .toggle-group button {
            flex: 1;
            border: none;
            background: transparent;
            padding: 8px 16px;
            font-size: 13px;
        }
        .toggle-group button.active {
            background: var(--bg-card);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Bar chart */
        .bar-chart {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            height: 120px;
            padding: 16px;
            background: var(--bg);
            border-radius: 8px;
            margin: 16px 0;
        }
        .bar {
            flex: 1;
            background: var(--accent);
            border-radius: 4px 4px 0 0;
            position: relative;
            transition: height 0.3s ease;
            min-width: 30px;
        }
        .bar-label {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: var(--text-muted);
            font-family: var(--font-mono);
        }
        .bar-value {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: var(--text);
            font-family: var(--font-mono);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Information Theory for Machine Learning</h1>
            <p class="subtitle">From bits to loss functions: why cross-entropy works</p>
        </header>

        <article>
            <p>Every ML practitioner uses cross-entropy loss. Few understand where it comes from. This tutorial builds it from first principles: surprise, entropy, and the cost of being wrong.</p>

            <h2>Surprise: The Atomic Unit</h2>
            <p class="section-label">Building block</p>

            <p>Start with a single event. If something unlikely happens, you're surprised. If something certain happens, you're not. We quantify this:</p>

            <div class="equation-block">
                <span class="equation-label">Surprise (Self-Information)</span>
                $$I(x) = -\log_2 P(x)$$
                <div class="equation-explanation">
                    The negative log of probability. Rare events (low P) give high surprise. Certain events (P=1) give zero surprise.
                </div>
            </div>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">surprise.py</span><span class="lang">python</span></div>
<pre><span class="keyword">import</span> <span class="variable">math</span>

<span class="keyword">def</span> <span class="function">surprise</span>(<span class="variable">p</span>):
<span class="highlight-line">    <span class="keyword">return</span> -<span class="variable">math</span>.<span class="function">log2</span>(<span class="variable">p</span>)</span>

<span class="function">surprise</span>(<span class="number">1.0</span>)   <span class="comment"># 0.0 bits (certain event)</span>
<span class="function">surprise</span>(<span class="number">0.5</span>)   <span class="comment"># 1.0 bit  (coin flip)</span>
<span class="function">surprise</span>(<span class="number">0.125</span>) <span class="comment"># 3.0 bits (1 in 8 chance)</span></pre>
            </div>

            <div class="visualization">
                <div class="viz-header">
                    <span class="viz-title">Surprise vs Probability</span>
                </div>
                <div class="viz-canvas-container">
                    <canvas id="surpriseCanvas" width="692" height="200"></canvas>
                </div>
                <div class="viz-controls">
                    <div class="slider-container" style="flex: 1;">
                        <span class="slider-label">P(x):</span>
                        <input type="range" id="surpriseSlider" min="1" max="99" value="50">
                        <span class="parameter-display" id="surpriseP">0.50</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Surprise:</span>
                        <span class="stat-value" id="surpriseValue">1.00 bits</span>
                    </div>
                </div>
            </div>

            <p>The log base determines units. Base 2 gives bits. Base e gives nats (used in ML). The shape is the same.</p>

            <h2>Entropy: Average Surprise</h2>
            <p class="section-label">Uncertainty of a distribution</p>

            <p>Entropy is the expected surprise across all outcomes. Weight each outcome's surprise by its probability:</p>

            <div class="equation-block">
                <span class="equation-label">Entropy</span>
                $$H(P) = \mathbb{E}[I(x)] = -\sum_x P(x) \log P(x)$$
                <div class="equation-explanation">
                    High entropy = high uncertainty = outcomes are spread out. Low entropy = low uncertainty = outcomes are concentrated.
                </div>
            </div>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">entropy.py</span><span class="lang">python</span></div>
<pre><span class="keyword">def</span> <span class="function">entropy</span>(<span class="variable">probs</span>):
    <span class="variable">total</span> = <span class="number">0</span>
<span class="highlight-line">    <span class="keyword">for</span> <span class="variable">p</span> <span class="keyword">in</span> <span class="variable">probs</span>:</span>
<span class="highlight-line">        <span class="keyword">if</span> <span class="variable">p</span> > <span class="number">0</span>:</span>
<span class="highlight-line">            <span class="variable">total</span> += <span class="variable">p</span> * <span class="function">surprise</span>(<span class="variable">p</span>)</span>
    <span class="keyword">return</span> <span class="variable">total</span>

<span class="comment"># Fair coin: maximum entropy for 2 outcomes</span>
<span class="function">entropy</span>([<span class="number">0.5</span>, <span class="number">0.5</span>])  <span class="comment"># 1.0 bit</span>
<span class="comment"># Loaded coin: lower entropy</span>
<span class="function">entropy</span>([<span class="number">0.9</span>, <span class="number">0.1</span>])  <span class="comment"># 0.47 bits</span></pre>
            </div>

            <div class="visualization">
                <div class="viz-header">
                    <span class="viz-title">Entropy of a Distribution</span>
                </div>
                <div class="bar-chart" id="entropyBars"></div>
                <div class="viz-controls">
                    <div class="slider-container" style="flex: 1;">
                        <span class="slider-label">Outcomes:</span>
                        <select id="entropyN">
                            <option value="2">2</option>
                            <option value="4">4</option>
                            <option value="6" selected>6</option>
                            <option value="8">8</option>
                        </select>
                    </div>
                    <div class="toggle-group">
                        <button id="btnFair" class="active" onclick="setDistribution('fair')">Uniform</button>
                        <button id="btnLoaded" onclick="setDistribution('loaded')">Loaded</button>
                    </div>
                </div>
                <div class="viz-stats">
                    <div class="stat-item">
                        <span class="stat-label">Entropy:</span>
                        <span class="stat-value" id="entropyValue">2.58 bits</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Max possible:</span>
                        <span class="stat-value" id="entropyMax">2.58 bits</span>
                    </div>
                </div>
            </div>

            <div class="callout blue">
                <div class="callout-title">Key Insight</div>
                <p style="margin: 0;">Entropy is maximized when all outcomes are equally likely. Any deviation from uniform reduces entropy. This is why loaded dice are "less random."</p>
            </div>

            <h2>Cross-Entropy: Surprise Under the Wrong Model</h2>
            <p class="section-label">Where loss functions come from</p>

            <p>In ML, we don't know the true distribution P. We have a model Q that approximates it. Cross-entropy measures the average surprise when the world follows P but we use Q to assign probabilities:</p>

            <div class="equation-block">
                <span class="equation-label">Cross-Entropy</span>
                $$H(P, Q) = -\sum_x P(x) \log Q(x)$$
                <div class="equation-explanation">
                    We sample from P (reality) but measure surprise using Q (our model). If Q matches P, cross-entropy equals entropy. If Q is wrong, cross-entropy is higher.
                </div>
            </div>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">cross_entropy.py</span><span class="lang">python</span></div>
<pre><span class="keyword">def</span> <span class="function">cross_entropy</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>):
    <span class="variable">total</span> = <span class="number">0</span>
<span class="highlight-line">    <span class="keyword">for</span> <span class="variable">p</span>, <span class="variable">q</span> <span class="keyword">in</span> <span class="function">zip</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>):</span>
<span class="highlight-line">        <span class="keyword">if</span> <span class="variable">p</span> > <span class="number">0</span>:</span>
<span class="highlight-line">            <span class="variable">total</span> += <span class="variable">p</span> * (-<span class="variable">math</span>.<span class="function">log</span>(<span class="variable">q</span>))  <span class="comment"># Note: natural log for ML</span></span>
    <span class="keyword">return</span> <span class="variable">total</span></pre>
            </div>

            <h3>Classification: One-Hot Labels</h3>

            <p>In classification, P is a one-hot vector: all probability on the true class k. Cross-entropy simplifies dramatically:</p>

            <div class="equation-block">
                <span class="equation-label">Classification Loss</span>
                $$H(P, Q) = -\log Q(k)$$
                <div class="equation-explanation">
                    Since P(k)=1 and P(j≠k)=0, only the true class term survives. This is why softmax cross-entropy is just -log(predicted probability of correct class).
                </div>
            </div>

            <div class="visualization">
                <div class="viz-header">
                    <span class="viz-title">Cross-Entropy Loss</span>
                </div>
                <div class="viz-canvas-container">
                    <canvas id="ceCanvas" width="692" height="200"></canvas>
                </div>
                <div class="viz-controls">
                    <div class="slider-container" style="flex: 1;">
                        <span class="slider-label">Q(correct class):</span>
                        <input type="range" id="ceSlider" min="1" max="99" value="70">
                        <span class="parameter-display" id="ceP">0.70</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Loss:</span>
                        <span class="stat-value" id="ceValue">0.36</span>
                    </div>
                </div>
            </div>

            <p>When Q(k) approaches 0, loss approaches infinity. The model is saying "this is impossible" but it happened. Infinite surprise.</p>

            <h2>KL Divergence: The Cost of Being Wrong</h2>
            <p class="section-label">Extra bits from model error</p>

            <p>KL divergence is the difference between cross-entropy and entropy. It measures how many extra bits of surprise we suffer because our model Q differs from reality P:</p>

            <div class="equation-block">
                <span class="equation-label">KL Divergence</span>
                $$D_{KL}(P \| Q) = H(P, Q) - H(P) = \sum_x P(x) \log \frac{P(x)}{Q(x)}$$
                <div class="equation-explanation">
                    If Q = P, the ratio is 1, log(1) = 0, and KL = 0. Any mismatch makes KL positive. KL is never negative.
                </div>
            </div>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">kl_divergence.py</span><span class="lang">python</span></div>
<pre><span class="keyword">def</span> <span class="function">kl_divergence</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>):
<span class="highlight-line">    <span class="keyword">return</span> <span class="function">cross_entropy</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>) - <span class="function">entropy</span>(<span class="variable">p_true</span>)</span>

<span class="comment"># Equivalent direct formula:</span>
<span class="keyword">def</span> <span class="function">kl_direct</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>):
    <span class="variable">total</span> = <span class="number">0</span>
    <span class="keyword">for</span> <span class="variable">p</span>, <span class="variable">q</span> <span class="keyword">in</span> <span class="function">zip</span>(<span class="variable">p_true</span>, <span class="variable">q_model</span>):
        <span class="keyword">if</span> <span class="variable">p</span> > <span class="number">0</span>:
            <span class="variable">total</span> += <span class="variable">p</span> * <span class="variable">math</span>.<span class="function">log</span>(<span class="variable">p</span> / <span class="variable">q</span>)
    <span class="keyword">return</span> <span class="variable">total</span></pre>
            </div>

            <div class="visualization">
                <div class="viz-header">
                    <span class="viz-title">KL Divergence (Binary Case)</span>
                </div>
                <div class="viz-canvas-container">
                    <canvas id="klCanvas" width="692" height="200"></canvas>
                </div>
                <div class="viz-controls">
                    <div class="slider-container">
                        <span class="slider-label">True P:</span>
                        <input type="range" id="klPSlider" min="1" max="99" value="50">
                        <span class="parameter-display" id="klPValue">0.50</span>
                    </div>
                    <div class="slider-container">
                        <span class="slider-label">Model Q:</span>
                        <input type="range" id="klQSlider" min="1" max="99" value="80">
                        <span class="parameter-display" id="klQValue">0.80</span>
                    </div>
                </div>
                <div class="viz-stats">
                    <div class="stat-item">
                        <span class="stat-label">H(P):</span>
                        <span class="stat-value" id="klEntropy">0.69</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">H(P,Q):</span>
                        <span class="stat-value" id="klCE">0.80</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">KL(P||Q):</span>
                        <span class="stat-value" id="klValue">0.11</span>
                    </div>
                </div>
            </div>

            <div class="callout accent">
                <div class="callout-title">Why Minimize Cross-Entropy?</div>
                <p style="margin: 0;">In classification, H(P) is fixed (it's 0 for one-hot labels). So minimizing cross-entropy H(P,Q) is equivalent to minimizing KL divergence. We're pushing our model Q toward the true distribution P.</p>
            </div>

            <h2>Binary Cross-Entropy</h2>
            <p class="section-label">Sigmoid output</p>

            <p>For binary classification, we have one output p = σ(z) representing P(y=1). The loss handles both cases:</p>

            <div class="equation-block">
                <span class="equation-label">Binary Cross-Entropy</span>
                $$L = -[y \log(p) + (1-y) \log(1-p)]$$
                <div class="equation-explanation">
                    If y=1, we want p high. If y=0, we want p low (so 1-p high). The formula penalizes confident wrong predictions heavily.
                </div>
            </div>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">bce.py</span><span class="lang">python</span></div>
<pre><span class="keyword">def</span> <span class="function">sigmoid</span>(<span class="variable">z</span>):
    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + <span class="variable">math</span>.<span class="function">exp</span>(-<span class="variable">z</span>))

<span class="keyword">def</span> <span class="function">bce_loss</span>(<span class="variable">y_true</span>, <span class="variable">p_pred</span>):
<span class="highlight-line">    <span class="keyword">if</span> <span class="variable">y_true</span> == <span class="number">1</span>:</span>
<span class="highlight-line">        <span class="keyword">return</span> -<span class="variable">math</span>.<span class="function">log</span>(<span class="variable">p_pred</span>)</span>
<span class="highlight-line">    <span class="keyword">else</span>:</span>
<span class="highlight-line">        <span class="keyword">return</span> -<span class="variable">math</span>.<span class="function">log</span>(<span class="number">1</span> - <span class="variable">p_pred</span>)</span></pre>
            </div>

            <div class="visualization">
                <div class="viz-header">
                    <span class="viz-title">BCE Loss</span>
                </div>
                <div class="viz-canvas-container">
                    <canvas id="bceCanvas" width="692" height="200"></canvas>
                </div>
                <div class="viz-controls">
                    <div class="slider-container">
                        <span class="slider-label">Logit z:</span>
                        <input type="range" id="bceZSlider" min="-400" max="400" value="100">
                        <span class="parameter-display" id="bceZ">1.00</span>
                    </div>
                    <div class="toggle-group">
                        <button id="bceY1" class="active" onclick="setBceY(1)">y = 1</button>
                        <button id="bceY0" onclick="setBceY(0)">y = 0</button>
                    </div>
                </div>
                <div class="viz-stats">
                    <div class="stat-item">
                        <span class="stat-label">σ(z):</span>
                        <span class="stat-value" id="bceSigmoid">0.73</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Loss:</span>
                        <span class="stat-value" id="bceLoss">0.31</span>
                    </div>
                </div>
            </div>

            <h2>The Takeaway</h2>

            <div class="code-breakdown">
                <div class="code-breakdown-header"><span class="title">summary.py</span><span class="lang">python</span></div>
<pre><span class="comment"># Surprise: information from one event</span>
<span class="variable">I</span> = -<span class="function">log</span>(<span class="variable">p</span>)

<span class="comment"># Entropy: average surprise (uncertainty of P)</span>
<span class="variable">H_P</span> = <span class="function">sum</span>(<span class="variable">p</span> * -<span class="function">log</span>(<span class="variable">p</span>) <span class="keyword">for</span> <span class="variable">p</span> <span class="keyword">in</span> <span class="variable">P</span>)

<span class="comment"># Cross-entropy: average surprise using wrong model</span>
<span class="variable">H_PQ</span> = <span class="function">sum</span>(<span class="variable">p</span> * -<span class="function">log</span>(<span class="variable">q</span>) <span class="keyword">for</span> <span class="variable">p</span>, <span class="variable">q</span> <span class="keyword">in</span> <span class="function">zip</span>(<span class="variable">P</span>, <span class="variable">Q</span>))

<span class="comment"># KL divergence: extra surprise from model error</span>
<span class="variable">KL</span> = <span class="variable">H_PQ</span> - <span class="variable">H_P</span>

<span class="comment"># Classification: P is one-hot, so H_P = 0</span>
<span class="comment"># Loss = H_PQ = -log(q_correct) = KL</span></pre>
            </div>

            <p>Cross-entropy loss is not arbitrary. It measures how surprised we are by the true labels when we use our model's predicted probabilities. Minimizing it pushes our model toward reality.</p>

        </article>

        <footer>
            <p>Interactive visualizations in vanilla JavaScript. No frameworks.</p>
        </footer>
    </div>

<script>
// Utility functions
const safeLog = (x) => Math.log(Math.max(x, 1e-12));
const safeLog2 = (x) => Math.log2(Math.max(x, 1e-12));
const sigmoid = (z) => 1 / (1 + Math.exp(-z));

// ================================================================
// SURPRISE VISUALIZATION
// ================================================================
const surpriseCanvas = document.getElementById('surpriseCanvas');
const surpriseCtx = surpriseCanvas.getContext('2d');

function drawSurprise() {
    const W = surpriseCanvas.width, H = surpriseCanvas.height;
    const pad = { left: 50, right: 20, top: 20, bottom: 40 };
    
    surpriseCtx.fillStyle = '#fff';
    surpriseCtx.fillRect(0, 0, W, H);
    
    // Draw axes
    surpriseCtx.strokeStyle = '#e5e4e2';
    surpriseCtx.lineWidth = 1;
    surpriseCtx.beginPath();
    surpriseCtx.moveTo(pad.left, pad.top);
    surpriseCtx.lineTo(pad.left, H - pad.bottom);
    surpriseCtx.lineTo(W - pad.right, H - pad.bottom);
    surpriseCtx.stroke();
    
    // Draw curve: I(x) = -log2(p)
    surpriseCtx.strokeStyle = '#c45d4a';
    surpriseCtx.lineWidth = 2.5;
    surpriseCtx.beginPath();
    for (let i = 0; i <= 100; i++) {
        const p = 0.01 + (i / 100) * 0.98;
        const surprise = -safeLog2(p);
        const x = pad.left + (i / 100) * (W - pad.left - pad.right);
        const y = H - pad.bottom - (surprise / 7) * (H - pad.top - pad.bottom);
        if (i === 0) surpriseCtx.moveTo(x, y);
        else surpriseCtx.lineTo(x, y);
    }
    surpriseCtx.stroke();
    
    // Current point
    const pVal = parseInt(document.getElementById('surpriseSlider').value) / 100;
    const sVal = -safeLog2(pVal);
    const px = pad.left + pVal * (W - pad.left - pad.right);
    const py = H - pad.bottom - (sVal / 7) * (H - pad.top - pad.bottom);
    
    surpriseCtx.fillStyle = '#c45d4a';
    surpriseCtx.beginPath();
    surpriseCtx.arc(px, py, 6, 0, Math.PI * 2);
    surpriseCtx.fill();
    
    // Labels
    surpriseCtx.fillStyle = '#6b7280';
    surpriseCtx.font = '12px Inter, sans-serif';
    surpriseCtx.textAlign = 'center';
    surpriseCtx.fillText('P(x)', W / 2, H - 8);
    
    surpriseCtx.save();
    surpriseCtx.translate(15, H / 2);
    surpriseCtx.rotate(-Math.PI / 2);
    surpriseCtx.fillText('Surprise (bits)', 0, 0);
    surpriseCtx.restore();
    
    // Update displays
    document.getElementById('surpriseP').textContent = pVal.toFixed(2);
    document.getElementById('surpriseValue').textContent = sVal.toFixed(2) + ' bits';
}

document.getElementById('surpriseSlider').addEventListener('input', drawSurprise);

// ================================================================
// ENTROPY VISUALIZATION
// ================================================================
let entropyDistribution = 'fair';

function updateEntropyBars() {
    const N = parseInt(document.getElementById('entropyN').value);
    const container = document.getElementById('entropyBars');
    container.innerHTML = '';
    
    let probs = [];
    if (entropyDistribution === 'fair') {
        probs = Array(N).fill(1 / N);
    } else {
        // Loaded: 70% on first, rest split
        probs = [0.7];
        for (let i = 1; i < N; i++) probs.push(0.3 / (N - 1));
    }
    
    // Calculate entropy
    let H = 0;
    for (const p of probs) {
        if (p > 0) H += p * (-safeLog2(p));
    }
    const maxH = Math.log2(N);
    
    // Draw bars
    const maxBarHeight = 100;
    for (let i = 0; i < N; i++) {
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = (probs[i] * maxBarHeight * N * 0.8) + 'px';
        bar.style.opacity = 0.6 + probs[i] * 2;
        
        const label = document.createElement('span');
        label.className = 'bar-label';
        label.textContent = (i + 1);
        bar.appendChild(label);
        
        const value = document.createElement('span');
        value.className = 'bar-value';
        value.textContent = probs[i].toFixed(2);
        bar.appendChild(value);
        
        container.appendChild(bar);
    }
    
    document.getElementById('entropyValue').textContent = H.toFixed(2) + ' bits';
    document.getElementById('entropyMax').textContent = maxH.toFixed(2) + ' bits';
}

function setDistribution(type) {
    entropyDistribution = type;
    document.getElementById('btnFair').classList.toggle('active', type === 'fair');
    document.getElementById('btnLoaded').classList.toggle('active', type === 'loaded');
    updateEntropyBars();
}

document.getElementById('entropyN').addEventListener('change', updateEntropyBars);

// ================================================================
// CROSS-ENTROPY VISUALIZATION
// ================================================================
const ceCanvas = document.getElementById('ceCanvas');
const ceCtx = ceCanvas.getContext('2d');

function drawCE() {
    const W = ceCanvas.width, H = ceCanvas.height;
    const pad = { left: 50, right: 20, top: 20, bottom: 40 };
    
    ceCtx.fillStyle = '#fff';
    ceCtx.fillRect(0, 0, W, H);
    
    // Draw axes
    ceCtx.strokeStyle = '#e5e4e2';
    ceCtx.lineWidth = 1;
    ceCtx.beginPath();
    ceCtx.moveTo(pad.left, pad.top);
    ceCtx.lineTo(pad.left, H - pad.bottom);
    ceCtx.lineTo(W - pad.right, H - pad.bottom);
    ceCtx.stroke();
    
    // Draw curve: -log(q)
    ceCtx.strokeStyle = '#c45d4a';
    ceCtx.lineWidth = 2.5;
    ceCtx.beginPath();
    for (let i = 0; i <= 100; i++) {
        const q = 0.01 + (i / 100) * 0.98;
        const loss = -safeLog(q);
        const x = pad.left + (i / 100) * (W - pad.left - pad.right);
        const y = H - pad.bottom - (loss / 5) * (H - pad.top - pad.bottom);
        if (i === 0) ceCtx.moveTo(x, y);
        else ceCtx.lineTo(x, y);
    }
    ceCtx.stroke();
    
    // Current point
    const qVal = parseInt(document.getElementById('ceSlider').value) / 100;
    const lossVal = -safeLog(qVal);
    const px = pad.left + qVal * (W - pad.left - pad.right);
    const py = H - pad.bottom - (lossVal / 5) * (H - pad.top - pad.bottom);
    
    ceCtx.fillStyle = '#c45d4a';
    ceCtx.beginPath();
    ceCtx.arc(px, py, 6, 0, Math.PI * 2);
    ceCtx.fill();
    
    // Labels
    ceCtx.fillStyle = '#6b7280';
    ceCtx.font = '12px Inter, sans-serif';
    ceCtx.textAlign = 'center';
    ceCtx.fillText('Q(correct class)', W / 2, H - 8);
    
    ceCtx.save();
    ceCtx.translate(15, H / 2);
    ceCtx.rotate(-Math.PI / 2);
    ceCtx.fillText('Loss', 0, 0);
    ceCtx.restore();
    
    document.getElementById('ceP').textContent = qVal.toFixed(2);
    document.getElementById('ceValue').textContent = lossVal.toFixed(2);
}

document.getElementById('ceSlider').addEventListener('input', drawCE);

// ================================================================
// KL DIVERGENCE VISUALIZATION
// ================================================================
const klCanvas = document.getElementById('klCanvas');
const klCtx = klCanvas.getContext('2d');

function drawKL() {
    const W = klCanvas.width, H = klCanvas.height;
    const pad = { left: 50, right: 20, top: 20, bottom: 40 };
    
    klCtx.fillStyle = '#fff';
    klCtx.fillRect(0, 0, W, H);
    
    const pVal = parseInt(document.getElementById('klPSlider').value) / 100;
    const qVal = parseInt(document.getElementById('klQSlider').value) / 100;
    
    // Draw bars for P and Q
    const barWidth = 80;
    const gap = 40;
    const centerX = W / 2;
    
    // P distribution bars
    const p0 = 1 - pVal, p1 = pVal;
    const q0 = 1 - qVal, q1 = qVal;
    const maxHeight = H - pad.top - pad.bottom - 30;
    
    // P bars (left)
    klCtx.fillStyle = '#4a90e2';
    klCtx.fillRect(centerX - gap - barWidth, H - pad.bottom - p0 * maxHeight, barWidth / 2 - 2, p0 * maxHeight);
    klCtx.fillRect(centerX - gap - barWidth / 2 + 2, H - pad.bottom - p1 * maxHeight, barWidth / 2 - 2, p1 * maxHeight);
    
    // Q bars (right)
    klCtx.fillStyle = '#c45d4a';
    klCtx.fillRect(centerX + gap, H - pad.bottom - q0 * maxHeight, barWidth / 2 - 2, q0 * maxHeight);
    klCtx.fillRect(centerX + gap + barWidth / 2 + 2, H - pad.bottom - q1 * maxHeight, barWidth / 2 - 2, q1 * maxHeight);
    
    // Labels
    klCtx.fillStyle = '#37352f';
    klCtx.font = '13px Inter, sans-serif';
    klCtx.textAlign = 'center';
    klCtx.fillText('P (true)', centerX - gap - barWidth / 2, H - 8);
    klCtx.fillText('Q (model)', centerX + gap + barWidth / 2, H - 8);
    
    klCtx.fillStyle = '#6b7280';
    klCtx.font = '11px JetBrains Mono, monospace';
    klCtx.fillText('0', centerX - gap - barWidth + barWidth / 4, H - pad.bottom + 15);
    klCtx.fillText('1', centerX - gap - barWidth / 4, H - pad.bottom + 15);
    klCtx.fillText('0', centerX + gap + barWidth / 4, H - pad.bottom + 15);
    klCtx.fillText('1', centerX + gap + barWidth * 3 / 4, H - pad.bottom + 15);
    
    // Calculate values
    const H_P = -(p0 * safeLog(p0) + p1 * safeLog(p1));
    const H_PQ = -(p0 * safeLog(q0) + p1 * safeLog(q1));
    const KL = H_PQ - H_P;
    
    document.getElementById('klPValue').textContent = pVal.toFixed(2);
    document.getElementById('klQValue').textContent = qVal.toFixed(2);
    document.getElementById('klEntropy').textContent = H_P.toFixed(2);
    document.getElementById('klCE').textContent = H_PQ.toFixed(2);
    document.getElementById('klValue').textContent = KL.toFixed(2);
}

document.getElementById('klPSlider').addEventListener('input', drawKL);
document.getElementById('klQSlider').addEventListener('input', drawKL);

// ================================================================
// BCE VISUALIZATION
// ================================================================
const bceCanvas = document.getElementById('bceCanvas');
const bceCtx = bceCanvas.getContext('2d');
let bceY = 1;

function drawBCE() {
    const W = bceCanvas.width, H = bceCanvas.height;
    const pad = { left: 50, right: 20, top: 20, bottom: 40 };
    
    bceCtx.fillStyle = '#fff';
    bceCtx.fillRect(0, 0, W, H);
    
    // Draw axes
    bceCtx.strokeStyle = '#e5e4e2';
    bceCtx.lineWidth = 1;
    bceCtx.beginPath();
    bceCtx.moveTo(pad.left, pad.top);
    bceCtx.lineTo(pad.left, H - pad.bottom);
    bceCtx.lineTo(W - pad.right, H - pad.bottom);
    bceCtx.stroke();
    
    // Draw sigmoid curve (faint)
    bceCtx.strokeStyle = '#4a90e2';
    bceCtx.lineWidth = 1.5;
    bceCtx.setLineDash([4, 4]);
    bceCtx.beginPath();
    for (let i = 0; i <= 100; i++) {
        const z = -4 + (i / 100) * 8;
        const s = sigmoid(z);
        const x = pad.left + (i / 100) * (W - pad.left - pad.right);
        const y = H - pad.bottom - s * (H - pad.top - pad.bottom) * 0.8;
        if (i === 0) bceCtx.moveTo(x, y);
        else bceCtx.lineTo(x, y);
    }
    bceCtx.stroke();
    bceCtx.setLineDash([]);
    
    // Draw loss curve
    bceCtx.strokeStyle = '#c45d4a';
    bceCtx.lineWidth = 2.5;
    bceCtx.beginPath();
    for (let i = 0; i <= 100; i++) {
        const z = -4 + (i / 100) * 8;
        const p = sigmoid(z);
        const loss = bceY === 1 ? -safeLog(p) : -safeLog(1 - p);
        const x = pad.left + (i / 100) * (W - pad.left - pad.right);
        const y = H - pad.bottom - (loss / 5) * (H - pad.top - pad.bottom);
        if (i === 0) bceCtx.moveTo(x, y);
        else bceCtx.lineTo(x, y);
    }
    bceCtx.stroke();
    
    // Current point
    const zVal = parseInt(document.getElementById('bceZSlider').value) / 100;
    const pVal = sigmoid(zVal);
    const lossVal = bceY === 1 ? -safeLog(pVal) : -safeLog(1 - pVal);
    
    const px = pad.left + ((zVal + 4) / 8) * (W - pad.left - pad.right);
    const py = H - pad.bottom - (lossVal / 5) * (H - pad.top - pad.bottom);
    
    bceCtx.fillStyle = '#c45d4a';
    bceCtx.beginPath();
    bceCtx.arc(px, py, 6, 0, Math.PI * 2);
    bceCtx.fill();
    
    // Labels
    bceCtx.fillStyle = '#6b7280';
    bceCtx.font = '12px Inter, sans-serif';
    bceCtx.textAlign = 'center';
    bceCtx.fillText('Logit z', W / 2, H - 8);
    
    document.getElementById('bceZ').textContent = zVal.toFixed(2);
    document.getElementById('bceSigmoid').textContent = pVal.toFixed(3);
    document.getElementById('bceLoss').textContent = lossVal.toFixed(3);
}

function setBceY(val) {
    bceY = val;
    document.getElementById('bceY0').classList.toggle('active', val === 0);
    document.getElementById('bceY1').classList.toggle('active', val === 1);
    drawBCE();
}

document.getElementById('bceZSlider').addEventListener('input', drawBCE);

// Initialize all
drawSurprise();
updateEntropyBars();
drawCE();
drawKL();
drawBCE();
</script>
</body>
</html>